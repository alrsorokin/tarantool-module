/* automatically generated by rust-bindgen 0.68.1 */

#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
use super::manual::FiberFunc;
use libc::*;
use tlua::ffi::lua_State;
type fiber_func = FiberFunc;
use super::manual::BoxTuple;
type tuple = BoxTuple;
type box_tuple_t = tuple;

pub type va_list = __builtin_va_list;
pub type lua_CFunction =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn box_on_shutdown(
        arg: *mut ::std::os::raw::c_void,
        new_handler: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        old_handler: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
pub const say_level_S_FATAL: say_level = 0;
pub const say_level_S_SYSERROR: say_level = 1;
pub const say_level_S_ERROR: say_level = 2;
pub const say_level_S_CRIT: say_level = 3;
pub const say_level_S_WARN: say_level = 4;
pub const say_level_S_INFO: say_level = 5;
pub const say_level_S_VERBOSE: say_level = 6;
pub const say_level_S_DEBUG: say_level = 7;
pub type say_level = ::std::os::raw::c_uint;
pub const say_format_SF_PLAIN: say_format = 0;
pub const say_format_SF_JSON: say_format = 1;
pub const say_format_say_format_MAX: say_format = 2;
pub type say_format = ::std::os::raw::c_uint;
extern "C" {
    pub static mut log_level: ::std::os::raw::c_int;
}
pub type sayfunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        ...
    ),
>;
extern "C" {
    pub static mut _say: sayfunc_t;
}
extern "C" {
    pub fn _say_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiber_attr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn fiber_attr_new() -> *mut fiber_attr;
}
extern "C" {
    pub fn fiber_attr_delete(fiber_attr: *mut fiber_attr);
}
extern "C" {
    pub fn fiber_attr_setstacksize(
        fiber_attr: *mut fiber_attr,
        stack_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiber_attr_getstacksize(fiber_attr: *mut fiber_attr) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiber {
    _unused: [u8; 0],
}
extern "C" {
    pub fn fiber_self() -> *mut fiber;
}
extern "C" {
    pub fn fiber_new(name: *const ::std::os::raw::c_char, f: fiber_func) -> *mut fiber;
}
extern "C" {
    pub fn fiber_new_ex(
        name: *const ::std::os::raw::c_char,
        fiber_attr: *const fiber_attr,
        f: fiber_func,
    ) -> *mut fiber;
}
extern "C" {
    pub fn fiber_yield();
}
extern "C" {
    pub fn fiber_start(callee: *mut fiber, ...);
}
extern "C" {
    pub fn fiber_wakeup(f: *mut fiber);
}
extern "C" {
    pub fn fiber_cancel(f: *mut fiber);
}
extern "C" {
    pub fn fiber_set_cancellable(yesno: bool) -> bool;
}
extern "C" {
    pub fn fiber_set_joinable(fiber: *mut fiber, yesno: bool);
}
extern "C" {
    pub fn fiber_join(f: *mut fiber) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiber_join_timeout(f: *mut fiber, timeout: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiber_sleep(s: f64);
}
extern "C" {
    pub fn fiber_is_cancelled() -> bool;
}
extern "C" {
    pub fn fiber_time() -> f64;
}
extern "C" {
    pub fn fiber_time64() -> i64;
}
extern "C" {
    pub fn fiber_clock() -> f64;
}
extern "C" {
    pub fn fiber_clock64() -> i64;
}
extern "C" {
    pub fn fiber_reschedule();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slab_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cord_slab_cache() -> *mut slab_cache;
}
extern "C" {
    pub fn box_region_used() -> usize;
}
extern "C" {
    pub fn box_region_alloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn box_region_aligned_alloc(size: usize, alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn box_region_truncate(size: usize);
}
extern "C" {
    pub fn fiber_set_name_n(fiber: *mut fiber, name: *const ::std::os::raw::c_char, len: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiber_cond {
    _unused: [u8; 0],
}
extern "C" {
    pub fn fiber_cond_new() -> *mut fiber_cond;
}
extern "C" {
    pub fn fiber_cond_delete(cond: *mut fiber_cond);
}
extern "C" {
    pub fn fiber_cond_signal(cond: *mut fiber_cond);
}
extern "C" {
    pub fn fiber_cond_broadcast(cond: *mut fiber_cond);
}
extern "C" {
    pub fn fiber_cond_wait_timeout(cond: *mut fiber_cond, timeout: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiber_cond_wait(cond: *mut fiber_cond) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iostream {
    pub vtab: *mut iostream_vtab,
    pub data: *mut ::std::os::raw::c_void,
    pub fd: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
    pub owner: *mut cord,
}
#[test]
fn bindgen_test_layout_iostream() {
    const UNINIT: ::std::mem::MaybeUninit<iostream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iostream>(),
        32usize,
        concat!("Size of: ", stringify!(iostream))
    );
    assert_eq!(
        ::std::mem::align_of::<iostream>(),
        8usize,
        concat!("Alignment of ", stringify!(iostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtab) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iostream),
            "::",
            stringify!(vtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iostream),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iostream),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(iostream),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iostream),
            "::",
            stringify!(owner)
        )
    );
}
extern "C" {
    pub fn plain_iostream_create(io: *mut iostream, fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn iostream_close(io: *mut iostream);
}
pub type ev_tstamp = f64;
extern "C" {
    pub static TIMEOUT_INFINITY: ev_tstamp;
}
extern "C" {
    pub fn coio_read_ahead_timeout(
        io: *mut iostream,
        buf: *mut ::std::os::raw::c_void,
        sz: usize,
        bufsiz: usize,
        timeout: ev_tstamp,
    ) -> isize;
}
extern "C" {
    pub fn coio_readn_ahead(
        io: *mut iostream,
        buf: *mut ::std::os::raw::c_void,
        sz: usize,
        bufsiz: usize,
    ) -> isize;
}
extern "C" {
    pub fn coio_write_timeout(
        io: *mut iostream,
        buf: *const ::std::os::raw::c_void,
        sz: usize,
        timeout: ev_tstamp,
    ) -> isize;
}
pub const COIO_READ: _bindgen_ty_1 = 1;
pub const COIO_WRITE: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn coio_wait(
        fd: ::std::os::raw::c_int,
        event: ::std::os::raw::c_int,
        timeout: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn coio_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn coio_getaddrinfo(
        host: *const ::std::os::raw::c_char,
        port: *const ::std::os::raw::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
        timeout: f64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibuf {
    _unused: [u8; 0],
}
pub type box_ibuf_t = ibuf;
extern "C" {
    pub fn box_ibuf_reserve(ibuf: *mut box_ibuf_t, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn box_ibuf_read_range(
        ibuf: *mut box_ibuf_t,
        rpos: *mut *mut *mut ::std::os::raw::c_char,
        wpos: *mut *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn box_ibuf_write_range(
        ibuf: *mut box_ibuf_t,
        wpos: *mut *mut *mut ::std::os::raw::c_char,
        end: *mut *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn luaL_iscdata(L: *mut lua_State, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaL_pushcdata(L: *mut lua_State, ctypeid: u32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn luaL_checkcdata(
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        ctypeid: *mut u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn luaL_setcdatagc(L: *mut lua_State, idx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn luaL_ctypeid(L: *mut lua_State, ctypename: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn luaL_cdef(
        L: *mut lua_State,
        ctypename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaL_pushuint64(L: *mut lua_State, val: u64);
}
extern "C" {
    pub fn luaL_pushint64(L: *mut lua_State, val: i64);
}
extern "C" {
    pub fn luaL_checkuint64(L: *mut lua_State, idx: ::std::os::raw::c_int) -> u64;
}
extern "C" {
    pub fn luaL_checkint64(L: *mut lua_State, idx: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    pub fn luaL_touint64(L: *mut lua_State, idx: ::std::os::raw::c_int) -> u64;
}
extern "C" {
    pub fn luaL_toint64(L: *mut lua_State, idx: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    pub fn luaT_call(
        L: *mut lua_State,
        nargs: ::std::os::raw::c_int,
        nreturns: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaT_dostring(
        L: *mut lua_State,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaT_cpcall(
        L: *mut lua_State,
        func: lua_CFunction,
        ud: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaT_state() -> *mut lua_State;
}
extern "C" {
    pub fn luaT_tolstring(
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        ssize: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn luaL_iscallable(L: *mut lua_State, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaT_toibuf(L: *mut lua_State, idx: ::std::os::raw::c_int) -> *mut box_ibuf_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct error {
    _unused: [u8; 0],
}
extern "C" {
    pub fn luaT_error(L: *mut lua_State) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaT_push_nil_and_error(L: *mut lua_State) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaT_pusherror(L: *mut lua_State, e: *mut error);
}
extern "C" {
    pub fn authenticate(
        user_name: *const ::std::os::raw::c_char,
        user_name_len: u32,
        salt: *const ::std::os::raw::c_char,
        tuple: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const txn_isolation_level_TXN_ISOLATION_DEFAULT: txn_isolation_level = 0;
pub const txn_isolation_level_TXN_ISOLATION_READ_COMMITTED: txn_isolation_level = 1;
pub const txn_isolation_level_TXN_ISOLATION_READ_CONFIRMED: txn_isolation_level = 2;
pub const txn_isolation_level_TXN_ISOLATION_BEST_EFFORT: txn_isolation_level = 3;
pub const txn_isolation_level_TXN_ISOLATION_LINEARIZABLE: txn_isolation_level = 4;
pub const txn_isolation_level_txn_isolation_level_MAX: txn_isolation_level = 5;
pub type txn_isolation_level = ::std::os::raw::c_uint;
extern "C" {
    pub fn box_txn_id() -> i64;
}
extern "C" {
    pub fn box_txn_isolation() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_txn() -> bool;
}
extern "C" {
    pub fn box_txn_begin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_txn_commit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_txn_rollback() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_txn_alloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn box_txn_set_timeout(timeout: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_txn_set_isolation(level: u32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tuple_format {
    _unused: [u8; 0],
}
pub type box_tuple_format_t = tuple_format;
extern "C" {
    pub fn box_tuple_format_default() -> *mut box_tuple_format_t;
}
extern "C" {
    pub fn box_tuple_ref(tuple: *mut box_tuple_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_tuple_unref(tuple: *mut box_tuple_t);
}
extern "C" {
    pub fn box_tuple_field_count(tuple: *mut box_tuple_t) -> u32;
}
extern "C" {
    pub fn box_tuple_bsize(tuple: *mut box_tuple_t) -> usize;
}
extern "C" {
    pub fn box_tuple_data_offset(tuple: *mut box_tuple_t) -> u16;
}
extern "C" {
    pub fn box_tuple_to_buf(
        tuple: *mut box_tuple_t,
        buf: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> isize;
}
extern "C" {
    pub fn box_tuple_format(tuple: *mut box_tuple_t) -> *mut box_tuple_format_t;
}
extern "C" {
    pub fn box_tuple_field(tuple: *mut box_tuple_t, fieldno: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn box_tuple_field_by_path(
        tuple: *mut box_tuple_t,
        path: *const ::std::os::raw::c_char,
        path_len: u32,
        index_base: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tuple_iterator {
    _unused: [u8; 0],
}
pub type box_tuple_iterator_t = tuple_iterator;
extern "C" {
    pub fn box_tuple_iterator(tuple: *mut box_tuple_t) -> *mut box_tuple_iterator_t;
}
extern "C" {
    pub fn box_tuple_iterator_free(it: *mut box_tuple_iterator_t);
}
extern "C" {
    pub fn box_tuple_position(it: *mut box_tuple_iterator_t) -> u32;
}
extern "C" {
    pub fn box_tuple_rewind(it: *mut box_tuple_iterator_t);
}
extern "C" {
    pub fn box_tuple_seek(
        it: *mut box_tuple_iterator_t,
        fieldno: u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn box_tuple_next(it: *mut box_tuple_iterator_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn box_tuple_new(
        format: *mut box_tuple_format_t,
        data: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
    ) -> *mut box_tuple_t;
}
extern "C" {
    pub fn box_tuple_update(
        tuple: *mut box_tuple_t,
        expr: *const ::std::os::raw::c_char,
        expr_end: *const ::std::os::raw::c_char,
    ) -> *mut box_tuple_t;
}
extern "C" {
    pub fn box_tuple_upsert(
        tuple: *mut box_tuple_t,
        expr: *const ::std::os::raw::c_char,
        expr_end: *const ::std::os::raw::c_char,
    ) -> *mut box_tuple_t;
}
extern "C" {
    pub fn box_tuple_validate(
        tuple: *mut box_tuple_t,
        format: *mut box_tuple_format_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_def {
    _unused: [u8; 0],
}
pub type box_key_def_t = key_def;
pub const BOX_KEY_PART_DEF_IS_NULLABLE: _bindgen_ty_2 = 1;
pub const BOX_KEY_PART_DEF_EXCLUDE_NULL: _bindgen_ty_2 = 2;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const BOX_KEY_PART_DEF_T_SIZE: _bindgen_ty_3 = 64;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union box_key_part_def_t {
    pub __bindgen_anon_1: box_key_part_def_t__bindgen_ty_1,
    pub padding: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct box_key_part_def_t__bindgen_ty_1 {
    pub fieldno: u32,
    pub flags: u32,
    pub field_type: *const ::std::os::raw::c_char,
    pub collation: *const ::std::os::raw::c_char,
    pub path: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_box_key_part_def_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<box_key_part_def_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<box_key_part_def_t__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(box_key_part_def_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<box_key_part_def_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(box_key_part_def_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fieldno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(box_key_part_def_t__bindgen_ty_1),
            "::",
            stringify!(fieldno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(box_key_part_def_t__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(box_key_part_def_t__bindgen_ty_1),
            "::",
            stringify!(field_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).collation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(box_key_part_def_t__bindgen_ty_1),
            "::",
            stringify!(collation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(box_key_part_def_t__bindgen_ty_1),
            "::",
            stringify!(path)
        )
    );
}
#[test]
fn bindgen_test_layout_box_key_part_def_t() {
    const UNINIT: ::std::mem::MaybeUninit<box_key_part_def_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<box_key_part_def_t>(),
        64usize,
        concat!("Size of: ", stringify!(box_key_part_def_t))
    );
    assert_eq!(
        ::std::mem::align_of::<box_key_part_def_t>(),
        1usize,
        concat!("Alignment of ", stringify!(box_key_part_def_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(box_key_part_def_t),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn box_key_def_new(
        fields: *mut u32,
        types: *mut u32,
        part_count: u32,
    ) -> *mut box_key_def_t;
}
extern "C" {
    pub fn box_key_part_def_create(part: *mut box_key_part_def_t);
}
extern "C" {
    pub fn box_key_def_new_v2(
        parts: *mut box_key_part_def_t,
        part_count: u32,
    ) -> *mut box_key_def_t;
}
extern "C" {
    pub fn box_key_def_dup(key_def: *const box_key_def_t) -> *mut box_key_def_t;
}
extern "C" {
    pub fn box_key_def_delete(key_def: *mut box_key_def_t);
}
extern "C" {
    pub fn box_key_def_dump_parts(
        key_def: *const box_key_def_t,
        part_count_ptr: *mut u32,
    ) -> *mut box_key_part_def_t;
}
extern "C" {
    pub fn box_key_def_validate_tuple(
        key_def: *mut box_key_def_t,
        tuple: *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_tuple_compare(
        tuple_a: *mut box_tuple_t,
        tuple_b: *mut box_tuple_t,
        key_def: *mut box_key_def_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_tuple_compare_with_key(
        tuple_a: *mut box_tuple_t,
        key_b: *const ::std::os::raw::c_char,
        key_def: *mut box_key_def_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_tuple_hash(tuple: *mut box_tuple_t, key_def: *mut box_key_def_t) -> u32;
}
extern "C" {
    pub fn box_key_def_merge(
        first: *const box_key_def_t,
        second: *const box_key_def_t,
    ) -> *mut box_key_def_t;
}
extern "C" {
    pub fn box_key_def_extract_key(
        key_def: *mut box_key_def_t,
        tuple: *mut box_tuple_t,
        multikey_idx: ::std::os::raw::c_int,
        key_size_ptr: *mut u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn box_key_def_validate_key(
        key_def: *const box_key_def_t,
        key: *const ::std::os::raw::c_char,
        key_size_ptr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_key_def_validate_full_key(
        key_def: *const box_key_def_t,
        key: *const ::std::os::raw::c_char,
        key_size_ptr: *mut u32,
    ) -> ::std::os::raw::c_int;
}
pub const field_type_FIELD_TYPE_ANY: field_type = 0;
pub const field_type_FIELD_TYPE_UNSIGNED: field_type = 1;
pub const field_type_FIELD_TYPE_STRING: field_type = 2;
pub const field_type_FIELD_TYPE_NUMBER: field_type = 3;
pub const field_type_FIELD_TYPE_DOUBLE: field_type = 4;
pub const field_type_FIELD_TYPE_INTEGER: field_type = 5;
pub const field_type_FIELD_TYPE_BOOLEAN: field_type = 6;
pub const field_type_FIELD_TYPE_VARBINARY: field_type = 7;
pub const field_type_FIELD_TYPE_SCALAR: field_type = 8;
pub const field_type_FIELD_TYPE_DECIMAL: field_type = 9;
pub const field_type_FIELD_TYPE_UUID: field_type = 10;
pub const field_type_FIELD_TYPE_DATETIME: field_type = 11;
pub const field_type_FIELD_TYPE_INTERVAL: field_type = 12;
pub const field_type_FIELD_TYPE_ARRAY: field_type = 13;
pub const field_type_FIELD_TYPE_MAP: field_type = 14;
pub const field_type_field_type_MAX: field_type = 15;
pub type field_type = ::std::os::raw::c_uint;
pub const on_conflict_action_ON_CONFLICT_ACTION_NONE: on_conflict_action = 0;
pub const on_conflict_action_ON_CONFLICT_ACTION_ROLLBACK: on_conflict_action = 1;
pub const on_conflict_action_ON_CONFLICT_ACTION_ABORT: on_conflict_action = 2;
pub const on_conflict_action_ON_CONFLICT_ACTION_FAIL: on_conflict_action = 3;
pub const on_conflict_action_ON_CONFLICT_ACTION_IGNORE: on_conflict_action = 4;
pub const on_conflict_action_ON_CONFLICT_ACTION_REPLACE: on_conflict_action = 5;
pub const on_conflict_action_ON_CONFLICT_ACTION_DEFAULT: on_conflict_action = 6;
pub const on_conflict_action_on_conflict_action_MAX: on_conflict_action = 7;
pub type on_conflict_action = ::std::os::raw::c_uint;
extern "C" {
    pub fn box_tuple_format_new(keys: *mut *mut key_def, key_count: u16)
        -> *mut box_tuple_format_t;
}
extern "C" {
    pub fn box_tuple_format_ref(format: *mut box_tuple_format_t);
}
extern "C" {
    pub fn box_tuple_format_unref(format: *mut box_tuple_format_t);
}
pub const BOX_SYSTEM_ID_MIN: _bindgen_ty_4 = 256;
pub const BOX_VINYL_DEFERRED_DELETE_ID: _bindgen_ty_4 = 257;
pub const BOX_SCHEMA_ID: _bindgen_ty_4 = 272;
pub const BOX_COLLATION_ID: _bindgen_ty_4 = 276;
pub const BOX_VCOLLATION_ID: _bindgen_ty_4 = 277;
pub const BOX_SPACE_ID: _bindgen_ty_4 = 280;
pub const BOX_VSPACE_ID: _bindgen_ty_4 = 281;
pub const BOX_SEQUENCE_ID: _bindgen_ty_4 = 284;
pub const BOX_SEQUENCE_DATA_ID: _bindgen_ty_4 = 285;
pub const BOX_VSEQUENCE_ID: _bindgen_ty_4 = 286;
pub const BOX_INDEX_ID: _bindgen_ty_4 = 288;
pub const BOX_VINDEX_ID: _bindgen_ty_4 = 289;
pub const BOX_FUNC_ID: _bindgen_ty_4 = 296;
pub const BOX_VFUNC_ID: _bindgen_ty_4 = 297;
pub const BOX_USER_ID: _bindgen_ty_4 = 304;
pub const BOX_VUSER_ID: _bindgen_ty_4 = 305;
pub const BOX_PRIV_ID: _bindgen_ty_4 = 312;
pub const BOX_VPRIV_ID: _bindgen_ty_4 = 313;
pub const BOX_CLUSTER_ID: _bindgen_ty_4 = 320;
pub const BOX_TRIGGER_ID: _bindgen_ty_4 = 328;
pub const BOX_TRUNCATE_ID: _bindgen_ty_4 = 330;
pub const BOX_SPACE_SEQUENCE_ID: _bindgen_ty_4 = 340;
pub const BOX_VSPACE_SEQUENCE_ID: _bindgen_ty_4 = 341;
pub const BOX_FK_CONSTRAINT_ID: _bindgen_ty_4 = 356;
pub const BOX_CK_CONSTRAINT_ID: _bindgen_ty_4 = 364;
pub const BOX_FUNC_INDEX_ID: _bindgen_ty_4 = 372;
pub const BOX_SESSION_SETTINGS_ID: _bindgen_ty_4 = 380;
pub const BOX_SYSTEM_ID_MAX: _bindgen_ty_4 = 511;
pub const BOX_ID_NIL: _bindgen_ty_4 = 2147483647;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
extern "C" {
    pub fn box_schema_version() -> u64;
}
pub type box_function_ctx_t = box_function_ctx;
pub const iproto_handler_status_IPROTO_HANDLER_OK: iproto_handler_status = 0;
pub const iproto_handler_status_IPROTO_HANDLER_ERROR: iproto_handler_status = 1;
pub const iproto_handler_status_IPROTO_HANDLER_FALLBACK: iproto_handler_status = 2;
pub type iproto_handler_status = ::std::os::raw::c_uint;
pub type iproto_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        header: *const ::std::os::raw::c_char,
        header_end: *const ::std::os::raw::c_char,
        body: *const ::std::os::raw::c_char,
        body_end: *const ::std::os::raw::c_char,
        ctx: *mut ::std::os::raw::c_void,
    ) -> iproto_handler_status,
>;
pub type iproto_handler_destroy_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn box_auth_data_prepare(
        method_name: *const ::std::os::raw::c_char,
        method_name_end: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        password_end: *const ::std::os::raw::c_char,
        user_name: *const ::std::os::raw::c_char,
        user_name_end: *const ::std::os::raw::c_char,
        data: *mut *const ::std::os::raw::c_char,
        data_end: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_return_tuple(
        ctx: *mut box_function_ctx_t,
        tuple: *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_return_mp(
        ctx: *mut box_function_ctx_t,
        mp: *const ::std::os::raw::c_char,
        mp_end: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_space_id_by_name(name: *const ::std::os::raw::c_char, len: u32) -> u32;
}
extern "C" {
    pub fn box_index_id_by_name(
        space_id: u32,
        name: *const ::std::os::raw::c_char,
        len: u32,
    ) -> u32;
}
extern "C" {
    pub fn box_insert(
        space_id: u32,
        tuple: *const ::std::os::raw::c_char,
        tuple_end: *const ::std::os::raw::c_char,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_replace(
        space_id: u32,
        tuple: *const ::std::os::raw::c_char,
        tuple_end: *const ::std::os::raw::c_char,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_delete(
        space_id: u32,
        index_id: u32,
        key: *const ::std::os::raw::c_char,
        key_end: *const ::std::os::raw::c_char,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_update(
        space_id: u32,
        index_id: u32,
        key: *const ::std::os::raw::c_char,
        key_end: *const ::std::os::raw::c_char,
        ops: *const ::std::os::raw::c_char,
        ops_end: *const ::std::os::raw::c_char,
        index_base: ::std::os::raw::c_int,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_upsert(
        space_id: u32,
        index_id: u32,
        tuple: *const ::std::os::raw::c_char,
        tuple_end: *const ::std::os::raw::c_char,
        ops: *const ::std::os::raw::c_char,
        ops_end: *const ::std::os::raw::c_char,
        index_base: ::std::os::raw::c_int,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_truncate(space_id: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_sequence_next(seq_id: u32, result: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_sequence_current(seq_id: u32, result: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_sequence_set(seq_id: u32, value: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_sequence_reset(seq_id: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_session_push(
        data: *const ::std::os::raw::c_char,
        data_end: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_session_id() -> u64;
}
extern "C" {
    pub fn box_session_su(uid: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_session_user_id(uid: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_effective_user_id() -> u32;
}
extern "C" {
    pub fn box_user_id_by_name(
        name: *const ::std::os::raw::c_char,
        name_end: *const ::std::os::raw::c_char,
        uid: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_iproto_send(
        sid: u64,
        header: *const ::std::os::raw::c_char,
        header_end: *const ::std::os::raw::c_char,
        body: *const ::std::os::raw::c_char,
        body_end: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_iproto_override(
        req_type: u32,
        handler: iproto_handler_t,
        destroy: iproto_handler_destroy_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iterator {
    _unused: [u8; 0],
}
pub type box_iterator_t = iterator;
extern "C" {
    pub fn box_index_iterator(
        space_id: u32,
        index_id: u32,
        type_: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        key_end: *const ::std::os::raw::c_char,
    ) -> *mut box_iterator_t;
}
extern "C" {
    pub fn box_iterator_next(
        iterator: *mut box_iterator_t,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_iterator_free(iterator: *mut box_iterator_t);
}
extern "C" {
    pub fn box_index_len(space_id: u32, index_id: u32) -> isize;
}
extern "C" {
    pub fn box_index_bsize(space_id: u32, index_id: u32) -> isize;
}
extern "C" {
    pub fn box_index_random(
        space_id: u32,
        index_id: u32,
        rnd: u32,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_index_get(
        space_id: u32,
        index_id: u32,
        key: *const ::std::os::raw::c_char,
        key_end: *const ::std::os::raw::c_char,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_index_min(
        space_id: u32,
        index_id: u32,
        key: *const ::std::os::raw::c_char,
        key_end: *const ::std::os::raw::c_char,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_index_max(
        space_id: u32,
        index_id: u32,
        key: *const ::std::os::raw::c_char,
        key_end: *const ::std::os::raw::c_char,
        result: *mut *mut box_tuple_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_index_count(
        space_id: u32,
        index_id: u32,
        type_: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        key_end: *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn box_tuple_extract_key(
        tuple: *mut box_tuple_t,
        space_id: u32,
        index_id: u32,
        key_size: *mut u32,
    ) -> *mut ::std::os::raw::c_char;
}
pub const iterator_type_ITER_EQ: iterator_type = 0;
pub const iterator_type_ITER_REQ: iterator_type = 1;
pub const iterator_type_ITER_ALL: iterator_type = 2;
pub const iterator_type_ITER_LT: iterator_type = 3;
pub const iterator_type_ITER_LE: iterator_type = 4;
pub const iterator_type_ITER_GE: iterator_type = 5;
pub const iterator_type_ITER_GT: iterator_type = 6;
pub const iterator_type_ITER_BITS_ALL_SET: iterator_type = 7;
pub const iterator_type_ITER_BITS_ANY_SET: iterator_type = 8;
pub const iterator_type_ITER_BITS_ALL_NOT_SET: iterator_type = 9;
pub const iterator_type_ITER_OVERLAPS: iterator_type = 10;
pub const iterator_type_ITER_NEIGHBOR: iterator_type = 11;
pub const iterator_type_iterator_type_MAX: iterator_type = 12;
pub type iterator_type = ::std::os::raw::c_uint;
pub type box_error_t = error;
extern "C" {
    pub fn box_error_type(error: *const box_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn box_error_code(error: *const box_error_t) -> u32;
}
extern "C" {
    pub fn box_error_message(error: *const box_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn box_error_last() -> *mut box_error_t;
}
extern "C" {
    pub fn box_error_clear();
}
extern "C" {
    pub fn box_error_set(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
        code: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn luaT_checktuple(L: *mut lua_State, idx: ::std::os::raw::c_int) -> *mut box_tuple_t;
}
extern "C" {
    pub fn luaT_pushtuple(L: *mut lua_State, tuple: *mut box_tuple_t);
}
extern "C" {
    pub fn luaT_istuple(L: *mut lua_State, idx: ::std::os::raw::c_int) -> *mut box_tuple_t;
}
extern "C" {
    pub fn luaT_tuple_encode(
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        tuple_len_ptr: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn luaT_tuple_new(
        L: *mut lua_State,
        idx: ::std::os::raw::c_int,
        format: *mut box_tuple_format_t,
    ) -> *mut box_tuple_t;
}
extern "C" {
    pub fn user_auth_method_name(
        name: *const ::std::os::raw::c_char,
        name_len: u32,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct box_latch {
    _unused: [u8; 0],
}
pub type box_latch_t = box_latch;
extern "C" {
    pub fn box_latch_new() -> *mut box_latch_t;
}
extern "C" {
    pub fn box_latch_delete(latch: *mut box_latch_t);
}
extern "C" {
    pub fn box_latch_lock(latch: *mut box_latch_t);
}
extern "C" {
    pub fn box_latch_trylock(latch: *mut box_latch_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_latch_unlock(latch: *mut box_latch_t);
}
extern "C" {
    pub fn clock_realtime() -> f64;
}
extern "C" {
    pub fn clock_monotonic() -> f64;
}
extern "C" {
    pub fn clock_process() -> f64;
}
extern "C" {
    pub fn clock_thread() -> f64;
}
extern "C" {
    pub fn clock_realtime64() -> i64;
}
extern "C" {
    pub fn clock_monotonic64() -> i64;
}
extern "C" {
    pub fn clock_process64() -> i64;
}
extern "C" {
    pub fn clock_thread64() -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct box_decimal {
    pub internal: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_box_decimal() {
    const UNINIT: ::std::mem::MaybeUninit<box_decimal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<box_decimal>(),
        64usize,
        concat!("Size of: ", stringify!(box_decimal))
    );
    assert_eq!(
        ::std::mem::align_of::<box_decimal>(),
        8usize,
        concat!("Alignment of ", stringify!(box_decimal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(box_decimal),
            "::",
            stringify!(internal)
        )
    );
}
pub type box_decimal_t = box_decimal;
extern "C" {
    pub fn box_decimal_precision(dec: *const box_decimal_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_decimal_scale(dec: *const box_decimal_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_decimal_is_int(dec: *const box_decimal_t) -> bool;
}
extern "C" {
    pub fn box_decimal_is_neg(dec: *const box_decimal_t) -> bool;
}
extern "C" {
    pub fn box_decimal_zero(dec: *mut box_decimal_t) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_from_string(
        dec: *mut box_decimal_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_from_double(dec: *mut box_decimal_t, d: f64) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_from_int64(dec: *mut box_decimal_t, num: i64) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_from_uint64(dec: *mut box_decimal_t, num: u64) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_copy(
        dest: *mut box_decimal_t,
        src: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_to_string(dec: *const box_decimal_t, buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn box_decimal_to_int64(dec: *const box_decimal_t, num: *mut i64) -> *const box_decimal_t;
}
extern "C" {
    pub fn box_decimal_to_uint64(dec: *const box_decimal_t, num: *mut u64) -> *const box_decimal_t;
}
extern "C" {
    pub fn box_decimal_round(
        dec: *mut box_decimal_t,
        scale: ::std::os::raw::c_int,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_floor(
        dec: *mut box_decimal_t,
        scale: ::std::os::raw::c_int,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_trim(dec: *mut box_decimal_t) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_rescale(
        dec: *mut box_decimal_t,
        scale: ::std::os::raw::c_int,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_compare(
        lhs: *const box_decimal_t,
        rhs: *const box_decimal_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box_decimal_abs(
        res: *mut box_decimal_t,
        dec: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_minus(
        res: *mut box_decimal_t,
        dec: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_add(
        res: *mut box_decimal_t,
        lhs: *const box_decimal_t,
        rhs: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_sub(
        res: *mut box_decimal_t,
        lhs: *const box_decimal_t,
        rhs: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_mul(
        res: *mut box_decimal_t,
        lhs: *const box_decimal_t,
        rhs: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_div(
        res: *mut box_decimal_t,
        lhs: *const box_decimal_t,
        rhs: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_remainder(
        res: *mut box_decimal_t,
        lhs: *const box_decimal_t,
        rhs: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_log10(
        res: *mut box_decimal_t,
        dec: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_ln(res: *mut box_decimal_t, dec: *const box_decimal_t)
        -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_pow(
        res: *mut box_decimal_t,
        lhs: *const box_decimal_t,
        rhs: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_exp(
        res: *mut box_decimal_t,
        dec: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_sqrt(
        res: *mut box_decimal_t,
        dec: *const box_decimal_t,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_mp_sizeof(dec: *const box_decimal_t) -> u32;
}
extern "C" {
    pub fn box_decimal_mp_encode(
        dec: *const box_decimal_t,
        data: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn box_decimal_mp_decode(
        dec: *mut box_decimal_t,
        data: *mut *const ::std::os::raw::c_char,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn box_decimal_mp_decode_data(
        dec: *mut box_decimal_t,
        data: *mut *const ::std::os::raw::c_char,
        size: u32,
    ) -> *mut box_decimal_t;
}
extern "C" {
    pub fn luaT_newdecimal(L: *mut lua_State) -> *mut box_decimal_t;
}
extern "C" {
    pub fn luaT_pushdecimal(L: *mut lua_State, dec: *const box_decimal_t) -> *mut box_decimal_t;
}
extern "C" {
    pub fn luaT_isdecimal(L: *mut lua_State, index: ::std::os::raw::c_int) -> *mut box_decimal_t;
}
extern "C" {
    pub fn random_bytes(buf: *mut ::std::os::raw::c_char, size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct port_vtab {
    pub dump_msgpack: ::std::option::Option<
        unsafe extern "C" fn(port: *mut port, out: *mut obuf) -> ::std::os::raw::c_int,
    >,
    pub dump_msgpack_16: ::std::option::Option<
        unsafe extern "C" fn(port: *mut port, out: *mut obuf) -> ::std::os::raw::c_int,
    >,
    pub dump_lua: ::std::option::Option<
        unsafe extern "C" fn(port: *mut port, L: *mut lua_State, is_flat: bool),
    >,
    pub dump_plain: ::std::option::Option<
        unsafe extern "C" fn(port: *mut port, size: *mut u32) -> *const ::std::os::raw::c_char,
    >,
    pub get_msgpack: ::std::option::Option<
        unsafe extern "C" fn(port: *mut port, size: *mut u32) -> *const ::std::os::raw::c_char,
    >,
    pub get_vdbemem: ::std::option::Option<
        unsafe extern "C" fn(port: *mut port, size: *mut u32) -> *mut sql_value,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(port: *mut port)>,
}
#[test]
fn bindgen_test_layout_port_vtab() {
    const UNINIT: ::std::mem::MaybeUninit<port_vtab> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<port_vtab>(),
        56usize,
        concat!("Size of: ", stringify!(port_vtab))
    );
    assert_eq!(
        ::std::mem::align_of::<port_vtab>(),
        8usize,
        concat!("Alignment of ", stringify!(port_vtab))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_msgpack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(port_vtab),
            "::",
            stringify!(dump_msgpack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_msgpack_16) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(port_vtab),
            "::",
            stringify!(dump_msgpack_16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_lua) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(port_vtab),
            "::",
            stringify!(dump_lua)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_plain) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(port_vtab),
            "::",
            stringify!(dump_plain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_msgpack) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(port_vtab),
            "::",
            stringify!(get_msgpack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_vdbemem) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(port_vtab),
            "::",
            stringify!(get_vdbemem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(port_vtab),
            "::",
            stringify!(destroy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct port {
    pub vtab: *const port_vtab,
    pub pad: [::std::os::raw::c_char; 68usize],
}
#[test]
fn bindgen_test_layout_port() {
    const UNINIT: ::std::mem::MaybeUninit<port> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<port>(),
        80usize,
        concat!("Size of: ", stringify!(port))
    );
    assert_eq!(
        ::std::mem::align_of::<port>(),
        8usize,
        concat!("Alignment of ", stringify!(port))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtab) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(port),
            "::",
            stringify!(vtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(port), "::", stringify!(pad))
    );
}
extern "C" {
    pub fn port_destroy(port: *mut port);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct port_c_entry {
    pub next: *mut port_c_entry,
    pub __bindgen_anon_1: port_c_entry__bindgen_ty_1,
    pub mp_size: u32,
    pub mp_format: *mut tuple_format,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union port_c_entry__bindgen_ty_1 {
    pub tuple: *mut tuple,
    pub mp: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_port_c_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<port_c_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<port_c_entry__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(port_c_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<port_c_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(port_c_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tuple) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c_entry__bindgen_ty_1),
            "::",
            stringify!(tuple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c_entry__bindgen_ty_1),
            "::",
            stringify!(mp)
        )
    );
}
#[test]
fn bindgen_test_layout_port_c_entry() {
    const UNINIT: ::std::mem::MaybeUninit<port_c_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<port_c_entry>(),
        32usize,
        concat!("Size of: ", stringify!(port_c_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<port_c_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(port_c_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c_entry),
            "::",
            stringify!(mp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp_format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c_entry),
            "::",
            stringify!(mp_format)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct port_c {
    pub vtab: *const port_vtab,
    pub first: *mut port_c_entry,
    pub last: *mut port_c_entry,
    pub first_entry: port_c_entry,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_port_c() {
    const UNINIT: ::std::mem::MaybeUninit<port_c> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<port_c>(),
        64usize,
        concat!("Size of: ", stringify!(port_c))
    );
    assert_eq!(
        ::std::mem::align_of::<port_c>(),
        8usize,
        concat!("Alignment of ", stringify!(port_c))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtab) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c),
            "::",
            stringify!(vtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_entry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c),
            "::",
            stringify!(first_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(port_c),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn port_c_create(base: *mut port);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct box_function_ctx {
    pub port: *mut port,
}
#[test]
fn bindgen_test_layout_box_function_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<box_function_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<box_function_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(box_function_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<box_function_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(box_function_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(box_function_ctx),
            "::",
            stringify!(port)
        )
    );
}
pub const box_error_code_ER_UNKNOWN: box_error_code = 0;
pub const box_error_code_ER_ILLEGAL_PARAMS: box_error_code = 1;
pub const box_error_code_ER_MEMORY_ISSUE: box_error_code = 2;
pub const box_error_code_ER_TUPLE_FOUND: box_error_code = 3;
pub const box_error_code_ER_TUPLE_NOT_FOUND: box_error_code = 4;
pub const box_error_code_ER_UNSUPPORTED: box_error_code = 5;
pub const box_error_code_ER_NONMASTER: box_error_code = 6;
pub const box_error_code_ER_READONLY: box_error_code = 7;
pub const box_error_code_ER_INJECTION: box_error_code = 8;
pub const box_error_code_ER_CREATE_SPACE: box_error_code = 9;
pub const box_error_code_ER_SPACE_EXISTS: box_error_code = 10;
pub const box_error_code_ER_DROP_SPACE: box_error_code = 11;
pub const box_error_code_ER_ALTER_SPACE: box_error_code = 12;
pub const box_error_code_ER_INDEX_TYPE: box_error_code = 13;
pub const box_error_code_ER_MODIFY_INDEX: box_error_code = 14;
pub const box_error_code_ER_LAST_DROP: box_error_code = 15;
pub const box_error_code_ER_TUPLE_FORMAT_LIMIT: box_error_code = 16;
pub const box_error_code_ER_DROP_PRIMARY_KEY: box_error_code = 17;
pub const box_error_code_ER_KEY_PART_TYPE: box_error_code = 18;
pub const box_error_code_ER_EXACT_MATCH: box_error_code = 19;
pub const box_error_code_ER_INVALID_MSGPACK: box_error_code = 20;
pub const box_error_code_ER_PROC_RET: box_error_code = 21;
pub const box_error_code_ER_TUPLE_NOT_ARRAY: box_error_code = 22;
pub const box_error_code_ER_FIELD_TYPE: box_error_code = 23;
pub const box_error_code_ER_INDEX_PART_TYPE_MISMATCH: box_error_code = 24;
pub const box_error_code_ER_UPDATE_SPLICE: box_error_code = 25;
pub const box_error_code_ER_UPDATE_ARG_TYPE: box_error_code = 26;
pub const box_error_code_ER_FORMAT_MISMATCH_INDEX_PART: box_error_code = 27;
pub const box_error_code_ER_UNKNOWN_UPDATE_OP: box_error_code = 28;
pub const box_error_code_ER_UPDATE_FIELD: box_error_code = 29;
pub const box_error_code_ER_FUNCTION_TX_ACTIVE: box_error_code = 30;
pub const box_error_code_ER_KEY_PART_COUNT: box_error_code = 31;
pub const box_error_code_ER_PROC_LUA: box_error_code = 32;
pub const box_error_code_ER_NO_SUCH_PROC: box_error_code = 33;
pub const box_error_code_ER_NO_SUCH_TRIGGER: box_error_code = 34;
pub const box_error_code_ER_NO_SUCH_INDEX_ID: box_error_code = 35;
pub const box_error_code_ER_NO_SUCH_SPACE: box_error_code = 36;
pub const box_error_code_ER_NO_SUCH_FIELD_NO: box_error_code = 37;
pub const box_error_code_ER_EXACT_FIELD_COUNT: box_error_code = 38;
pub const box_error_code_ER_FIELD_MISSING: box_error_code = 39;
pub const box_error_code_ER_WAL_IO: box_error_code = 40;
pub const box_error_code_ER_MORE_THAN_ONE_TUPLE: box_error_code = 41;
pub const box_error_code_ER_ACCESS_DENIED: box_error_code = 42;
pub const box_error_code_ER_CREATE_USER: box_error_code = 43;
pub const box_error_code_ER_DROP_USER: box_error_code = 44;
pub const box_error_code_ER_NO_SUCH_USER: box_error_code = 45;
pub const box_error_code_ER_USER_EXISTS: box_error_code = 46;
pub const box_error_code_ER_CREDS_MISMATCH: box_error_code = 47;
pub const box_error_code_ER_UNKNOWN_REQUEST_TYPE: box_error_code = 48;
pub const box_error_code_ER_UNKNOWN_SCHEMA_OBJECT: box_error_code = 49;
pub const box_error_code_ER_CREATE_FUNCTION: box_error_code = 50;
pub const box_error_code_ER_NO_SUCH_FUNCTION: box_error_code = 51;
pub const box_error_code_ER_FUNCTION_EXISTS: box_error_code = 52;
pub const box_error_code_ER_BEFORE_REPLACE_RET: box_error_code = 53;
pub const box_error_code_ER_MULTISTATEMENT_TRANSACTION: box_error_code = 54;
pub const box_error_code_ER_TRIGGER_EXISTS: box_error_code = 55;
pub const box_error_code_ER_USER_MAX: box_error_code = 56;
pub const box_error_code_ER_NO_SUCH_ENGINE: box_error_code = 57;
pub const box_error_code_ER_RELOAD_CFG: box_error_code = 58;
pub const box_error_code_ER_CFG: box_error_code = 59;
pub const box_error_code_ER_SAVEPOINT_EMPTY_TX: box_error_code = 60;
pub const box_error_code_ER_NO_SUCH_SAVEPOINT: box_error_code = 61;
pub const box_error_code_ER_UNKNOWN_REPLICA: box_error_code = 62;
pub const box_error_code_ER_REPLICASET_UUID_MISMATCH: box_error_code = 63;
pub const box_error_code_ER_INVALID_UUID: box_error_code = 64;
pub const box_error_code_ER_REPLICASET_UUID_IS_RO: box_error_code = 65;
pub const box_error_code_ER_INSTANCE_UUID_MISMATCH: box_error_code = 66;
pub const box_error_code_ER_REPLICA_ID_IS_RESERVED: box_error_code = 67;
pub const box_error_code_ER_INVALID_ORDER: box_error_code = 68;
pub const box_error_code_ER_MISSING_REQUEST_FIELD: box_error_code = 69;
pub const box_error_code_ER_IDENTIFIER: box_error_code = 70;
pub const box_error_code_ER_DROP_FUNCTION: box_error_code = 71;
pub const box_error_code_ER_ITERATOR_TYPE: box_error_code = 72;
pub const box_error_code_ER_REPLICA_MAX: box_error_code = 73;
pub const box_error_code_ER_INVALID_XLOG: box_error_code = 74;
pub const box_error_code_ER_INVALID_XLOG_NAME: box_error_code = 75;
pub const box_error_code_ER_INVALID_XLOG_ORDER: box_error_code = 76;
pub const box_error_code_ER_NO_CONNECTION: box_error_code = 77;
pub const box_error_code_ER_TIMEOUT: box_error_code = 78;
pub const box_error_code_ER_ACTIVE_TRANSACTION: box_error_code = 79;
pub const box_error_code_ER_CURSOR_NO_TRANSACTION: box_error_code = 80;
pub const box_error_code_ER_CROSS_ENGINE_TRANSACTION: box_error_code = 81;
pub const box_error_code_ER_NO_SUCH_ROLE: box_error_code = 82;
pub const box_error_code_ER_ROLE_EXISTS: box_error_code = 83;
pub const box_error_code_ER_CREATE_ROLE: box_error_code = 84;
pub const box_error_code_ER_INDEX_EXISTS: box_error_code = 85;
pub const box_error_code_ER_SESSION_CLOSED: box_error_code = 86;
pub const box_error_code_ER_ROLE_LOOP: box_error_code = 87;
pub const box_error_code_ER_GRANT: box_error_code = 88;
pub const box_error_code_ER_PRIV_GRANTED: box_error_code = 89;
pub const box_error_code_ER_ROLE_GRANTED: box_error_code = 90;
pub const box_error_code_ER_PRIV_NOT_GRANTED: box_error_code = 91;
pub const box_error_code_ER_ROLE_NOT_GRANTED: box_error_code = 92;
pub const box_error_code_ER_MISSING_SNAPSHOT: box_error_code = 93;
pub const box_error_code_ER_CANT_UPDATE_PRIMARY_KEY: box_error_code = 94;
pub const box_error_code_ER_UPDATE_INTEGER_OVERFLOW: box_error_code = 95;
pub const box_error_code_ER_GUEST_USER_PASSWORD: box_error_code = 96;
pub const box_error_code_ER_TRANSACTION_CONFLICT: box_error_code = 97;
pub const box_error_code_ER_UNSUPPORTED_PRIV: box_error_code = 98;
pub const box_error_code_ER_LOAD_FUNCTION: box_error_code = 99;
pub const box_error_code_ER_FUNCTION_LANGUAGE: box_error_code = 100;
pub const box_error_code_ER_RTREE_RECT: box_error_code = 101;
pub const box_error_code_ER_PROC_C: box_error_code = 102;
pub const box_error_code_ER_UNKNOWN_RTREE_INDEX_DISTANCE_TYPE: box_error_code = 103;
pub const box_error_code_ER_PROTOCOL: box_error_code = 104;
pub const box_error_code_ER_UPSERT_UNIQUE_SECONDARY_KEY: box_error_code = 105;
pub const box_error_code_ER_WRONG_INDEX_RECORD: box_error_code = 106;
pub const box_error_code_ER_WRONG_INDEX_PARTS: box_error_code = 107;
pub const box_error_code_ER_WRONG_INDEX_OPTIONS: box_error_code = 108;
pub const box_error_code_ER_WRONG_SCHEMA_VERSION: box_error_code = 109;
pub const box_error_code_ER_MEMTX_MAX_TUPLE_SIZE: box_error_code = 110;
pub const box_error_code_ER_WRONG_SPACE_OPTIONS: box_error_code = 111;
pub const box_error_code_ER_UNSUPPORTED_INDEX_FEATURE: box_error_code = 112;
pub const box_error_code_ER_VIEW_IS_RO: box_error_code = 113;
pub const box_error_code_ER_NO_TRANSACTION: box_error_code = 114;
pub const box_error_code_ER_SYSTEM: box_error_code = 115;
pub const box_error_code_ER_LOADING: box_error_code = 116;
pub const box_error_code_ER_CONNECTION_TO_SELF: box_error_code = 117;
pub const box_error_code_ER_KEY_PART_IS_TOO_LONG: box_error_code = 118;
pub const box_error_code_ER_COMPRESSION: box_error_code = 119;
pub const box_error_code_ER_CHECKPOINT_IN_PROGRESS: box_error_code = 120;
pub const box_error_code_ER_SUB_STMT_MAX: box_error_code = 121;
pub const box_error_code_ER_COMMIT_IN_SUB_STMT: box_error_code = 122;
pub const box_error_code_ER_ROLLBACK_IN_SUB_STMT: box_error_code = 123;
pub const box_error_code_ER_DECOMPRESSION: box_error_code = 124;
pub const box_error_code_ER_INVALID_XLOG_TYPE: box_error_code = 125;
pub const box_error_code_ER_ALREADY_RUNNING: box_error_code = 126;
pub const box_error_code_ER_INDEX_FIELD_COUNT_LIMIT: box_error_code = 127;
pub const box_error_code_ER_LOCAL_INSTANCE_ID_IS_READ_ONLY: box_error_code = 128;
pub const box_error_code_ER_BACKUP_IN_PROGRESS: box_error_code = 129;
pub const box_error_code_ER_READ_VIEW_ABORTED: box_error_code = 130;
pub const box_error_code_ER_INVALID_INDEX_FILE: box_error_code = 131;
pub const box_error_code_ER_INVALID_RUN_FILE: box_error_code = 132;
pub const box_error_code_ER_INVALID_VYLOG_FILE: box_error_code = 133;
pub const box_error_code_ER_CASCADE_ROLLBACK: box_error_code = 134;
pub const box_error_code_ER_VY_QUOTA_TIMEOUT: box_error_code = 135;
pub const box_error_code_ER_PARTIAL_KEY: box_error_code = 136;
pub const box_error_code_ER_TRUNCATE_SYSTEM_SPACE: box_error_code = 137;
pub const box_error_code_ER_LOAD_MODULE: box_error_code = 138;
pub const box_error_code_ER_VINYL_MAX_TUPLE_SIZE: box_error_code = 139;
pub const box_error_code_ER_WRONG_DD_VERSION: box_error_code = 140;
pub const box_error_code_ER_WRONG_SPACE_FORMAT: box_error_code = 141;
pub const box_error_code_ER_CREATE_SEQUENCE: box_error_code = 142;
pub const box_error_code_ER_ALTER_SEQUENCE: box_error_code = 143;
pub const box_error_code_ER_DROP_SEQUENCE: box_error_code = 144;
pub const box_error_code_ER_NO_SUCH_SEQUENCE: box_error_code = 145;
pub const box_error_code_ER_SEQUENCE_EXISTS: box_error_code = 146;
pub const box_error_code_ER_SEQUENCE_OVERFLOW: box_error_code = 147;
pub const box_error_code_ER_NO_SUCH_INDEX_NAME: box_error_code = 148;
pub const box_error_code_ER_SPACE_FIELD_IS_DUPLICATE: box_error_code = 149;
pub const box_error_code_ER_CANT_CREATE_COLLATION: box_error_code = 150;
pub const box_error_code_ER_WRONG_COLLATION_OPTIONS: box_error_code = 151;
pub const box_error_code_ER_NULLABLE_PRIMARY: box_error_code = 152;
pub const box_error_code_ER_NO_SUCH_FIELD_NAME_IN_SPACE: box_error_code = 153;
pub const box_error_code_ER_TRANSACTION_YIELD: box_error_code = 154;
pub const box_error_code_ER_NO_SUCH_GROUP: box_error_code = 155;
pub const box_error_code_ER_SQL_BIND_VALUE: box_error_code = 156;
pub const box_error_code_ER_SQL_BIND_TYPE: box_error_code = 157;
pub const box_error_code_ER_SQL_BIND_PARAMETER_MAX: box_error_code = 158;
pub const box_error_code_ER_SQL_EXECUTE: box_error_code = 159;
pub const box_error_code_ER_UPDATE_DECIMAL_OVERFLOW: box_error_code = 160;
pub const box_error_code_ER_SQL_BIND_NOT_FOUND: box_error_code = 161;
pub const box_error_code_ER_ACTION_MISMATCH: box_error_code = 162;
pub const box_error_code_ER_VIEW_MISSING_SQL: box_error_code = 163;
pub const box_error_code_ER_FOREIGN_KEY_CONSTRAINT: box_error_code = 164;
pub const box_error_code_ER_NO_SUCH_MODULE: box_error_code = 165;
pub const box_error_code_ER_NO_SUCH_COLLATION: box_error_code = 166;
pub const box_error_code_ER_CREATE_FK_CONSTRAINT: box_error_code = 167;
pub const box_error_code_ER_DROP_FK_CONSTRAINT: box_error_code = 168;
pub const box_error_code_ER_NO_SUCH_CONSTRAINT: box_error_code = 169;
pub const box_error_code_ER_CONSTRAINT_EXISTS: box_error_code = 170;
pub const box_error_code_ER_SQL_TYPE_MISMATCH: box_error_code = 171;
pub const box_error_code_ER_ROWID_OVERFLOW: box_error_code = 172;
pub const box_error_code_ER_DROP_COLLATION: box_error_code = 173;
pub const box_error_code_ER_ILLEGAL_COLLATION_MIX: box_error_code = 174;
pub const box_error_code_ER_SQL_NO_SUCH_PRAGMA: box_error_code = 175;
pub const box_error_code_ER_SQL_CANT_RESOLVE_FIELD: box_error_code = 176;
pub const box_error_code_ER_INDEX_EXISTS_IN_SPACE: box_error_code = 177;
pub const box_error_code_ER_INCONSISTENT_TYPES: box_error_code = 178;
pub const box_error_code_ER_SQL_SYNTAX_WITH_POS: box_error_code = 179;
pub const box_error_code_ER_SQL_STACK_OVERFLOW: box_error_code = 180;
pub const box_error_code_ER_SQL_SELECT_WILDCARD: box_error_code = 181;
pub const box_error_code_ER_SQL_STATEMENT_EMPTY: box_error_code = 182;
pub const box_error_code_ER_SQL_KEYWORD_IS_RESERVED: box_error_code = 183;
pub const box_error_code_ER_SQL_SYNTAX_NEAR_TOKEN: box_error_code = 184;
pub const box_error_code_ER_SQL_UNKNOWN_TOKEN: box_error_code = 185;
pub const box_error_code_ER_SQL_PARSER_GENERIC: box_error_code = 186;
pub const box_error_code_ER_SQL_ANALYZE_ARGUMENT: box_error_code = 187;
pub const box_error_code_ER_SQL_COLUMN_COUNT_MAX: box_error_code = 188;
pub const box_error_code_ER_HEX_LITERAL_MAX: box_error_code = 189;
pub const box_error_code_ER_INT_LITERAL_MAX: box_error_code = 190;
pub const box_error_code_ER_SQL_PARSER_LIMIT: box_error_code = 191;
pub const box_error_code_ER_INDEX_DEF_UNSUPPORTED: box_error_code = 192;
pub const box_error_code_ER_CK_DEF_UNSUPPORTED: box_error_code = 193;
pub const box_error_code_ER_MULTIKEY_INDEX_MISMATCH: box_error_code = 194;
pub const box_error_code_ER_CREATE_CK_CONSTRAINT: box_error_code = 195;
pub const box_error_code_ER_CK_CONSTRAINT_FAILED: box_error_code = 196;
pub const box_error_code_ER_SQL_COLUMN_COUNT: box_error_code = 197;
pub const box_error_code_ER_FUNC_INDEX_FUNC: box_error_code = 198;
pub const box_error_code_ER_FUNC_INDEX_FORMAT: box_error_code = 199;
pub const box_error_code_ER_FUNC_INDEX_PARTS: box_error_code = 200;
pub const box_error_code_ER_NO_SUCH_FIELD_NAME: box_error_code = 201;
pub const box_error_code_ER_FUNC_WRONG_ARG_COUNT: box_error_code = 202;
pub const box_error_code_ER_BOOTSTRAP_READONLY: box_error_code = 203;
pub const box_error_code_ER_SQL_FUNC_WRONG_RET_COUNT: box_error_code = 204;
pub const box_error_code_ER_FUNC_INVALID_RETURN_TYPE: box_error_code = 205;
pub const box_error_code_ER_SQL_PARSER_GENERIC_WITH_POS: box_error_code = 206;
pub const box_error_code_ER_REPLICA_NOT_ANON: box_error_code = 207;
pub const box_error_code_ER_CANNOT_REGISTER: box_error_code = 208;
pub const box_error_code_ER_SESSION_SETTING_INVALID_VALUE: box_error_code = 209;
pub const box_error_code_ER_SQL_PREPARE: box_error_code = 210;
pub const box_error_code_ER_WRONG_QUERY_ID: box_error_code = 211;
pub const box_error_code_ER_SEQUENCE_NOT_STARTED: box_error_code = 212;
pub const box_error_code_ER_NO_SUCH_SESSION_SETTING: box_error_code = 213;
pub const box_error_code_ER_UNCOMMITTED_FOREIGN_SYNC_TXNS: box_error_code = 214;
pub const box_error_code_ER_SYNC_MASTER_MISMATCH: box_error_code = 215;
pub const box_error_code_ER_SYNC_QUORUM_TIMEOUT: box_error_code = 216;
pub const box_error_code_ER_SYNC_ROLLBACK: box_error_code = 217;
pub const box_error_code_ER_TUPLE_METADATA_IS_TOO_BIG: box_error_code = 218;
pub const box_error_code_ER_XLOG_GAP: box_error_code = 219;
pub const box_error_code_ER_TOO_EARLY_SUBSCRIBE: box_error_code = 220;
pub const box_error_code_ER_SQL_CANT_ADD_AUTOINC: box_error_code = 221;
pub const box_error_code_ER_QUORUM_WAIT: box_error_code = 222;
pub const box_error_code_ER_INTERFERING_PROMOTE: box_error_code = 223;
pub const box_error_code_ER_ELECTION_DISABLED: box_error_code = 224;
pub const box_error_code_ER_TXN_ROLLBACK: box_error_code = 225;
pub const box_error_code_ER_NOT_LEADER: box_error_code = 226;
pub const box_error_code_ER_SYNC_QUEUE_UNCLAIMED: box_error_code = 227;
pub const box_error_code_ER_SYNC_QUEUE_FOREIGN: box_error_code = 228;
pub const box_error_code_ER_UNABLE_TO_PROCESS_IN_STREAM: box_error_code = 229;
pub const box_error_code_ER_UNABLE_TO_PROCESS_OUT_OF_STREAM: box_error_code = 230;
pub const box_error_code_ER_TRANSACTION_TIMEOUT: box_error_code = 231;
pub const box_error_code_ER_ACTIVE_TIMER: box_error_code = 232;
pub const box_error_code_ER_TUPLE_FIELD_COUNT_LIMIT: box_error_code = 233;
pub const box_error_code_ER_CREATE_CONSTRAINT: box_error_code = 234;
pub const box_error_code_ER_FIELD_CONSTRAINT_FAILED: box_error_code = 235;
pub const box_error_code_ER_TUPLE_CONSTRAINT_FAILED: box_error_code = 236;
pub const box_error_code_ER_CREATE_FOREIGN_KEY: box_error_code = 237;
pub const box_error_code_ER_FOREIGN_KEY_INTEGRITY: box_error_code = 238;
pub const box_error_code_ER_FIELD_FOREIGN_KEY_FAILED: box_error_code = 239;
pub const box_error_code_ER_COMPLEX_FOREIGN_KEY_FAILED: box_error_code = 240;
pub const box_error_code_ER_WRONG_SPACE_UPGRADE_OPTIONS: box_error_code = 241;
pub const box_error_code_ER_NO_ELECTION_QUORUM: box_error_code = 242;
pub const box_error_code_ER_SSL: box_error_code = 243;
pub const box_error_code_ER_SPLIT_BRAIN: box_error_code = 244;
pub const box_error_code_ER_OLD_TERM: box_error_code = 245;
pub const box_error_code_ER_INTERFERING_ELECTIONS: box_error_code = 246;
pub const box_error_code_ER_ITERATOR_POSITION: box_error_code = 247;
pub const box_error_code_ER_DEFAULT_VALUE_TYPE: box_error_code = 248;
pub const box_error_code_ER_UNKNOWN_AUTH_METHOD: box_error_code = 249;
pub const box_error_code_ER_INVALID_AUTH_DATA: box_error_code = 250;
pub const box_error_code_ER_INVALID_AUTH_REQUEST: box_error_code = 251;
pub const box_error_code_ER_WEAK_PASSWORD: box_error_code = 252;
pub const box_error_code_ER_OLD_PASSWORD: box_error_code = 253;
pub const box_error_code_ER_NO_SUCH_SESSION: box_error_code = 254;
pub const box_error_code_ER_WRONG_SESSION_TYPE: box_error_code = 255;
pub const box_error_code_ER_PASSWORD_EXPIRED: box_error_code = 256;
pub const box_error_code_ER_AUTH_DELAY: box_error_code = 257;
pub const box_error_code_ER_AUTH_REQUIRED: box_error_code = 258;
pub const box_error_code_ER_SQL_SEQ_SCAN: box_error_code = 259;
pub const box_error_code_ER_NO_SUCH_EVENT: box_error_code = 260;
pub const box_error_code_ER_BOOTSTRAP_NOT_UNANIMOUS: box_error_code = 261;
pub const box_error_code_ER_CANT_CHECK_BOOTSTRAP_LEADER: box_error_code = 262;
pub const box_error_code_ER_BOOTSTRAP_CONNECTION_NOT_TO_ALL: box_error_code = 263;
pub const box_error_code_ER_NIL_UUID: box_error_code = 264;
pub const box_error_code_ER_WRONG_FUNCTION_OPTIONS: box_error_code = 265;
pub const box_error_code_ER_MISSING_SYSTEM_SPACES: box_error_code = 266;
pub const box_error_code_ER_EXCEEDED_VDBE_MAX_STEPS: box_error_code = 267;
pub const box_error_code_ER_ILLEGAL_OPTIONS: box_error_code = 268;
pub const box_error_code_ER_ILLEGAL_OPTIONS_FORMAT: box_error_code = 269;
pub const box_error_code_box_error_code_MAX: box_error_code = 270;
pub type box_error_code = ::std::os::raw::c_uint;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iostream_vtab {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cord {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sql_value {
    pub _address: u8,
}
